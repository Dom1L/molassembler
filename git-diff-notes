diff --git a/CMakeLists.txt b/CMakeLists.txt
index 432fde8..e7447f7 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -7,7 +7,7 @@ cmake_minimum_required(VERSION 3.5.1)
 
 # little variables
 set(WARNING_FLAGS "-Wall -Wpedantic -Wextra")
-set(CLANG_CONSTEXPR_OPTIONS "-fconstexpr-steps=999999999 -fconstexpr-backtrace-limit=0")
+set(CLANG_CONSTEXPR_OPTIONS "-fconstexpr-steps=1999999999 -fconstexpr-backtrace-limit=0")
 
 # declaration
 project(SymmetryInformation)
diff --git a/ConstexprProperties.h b/ConstexprProperties.h
index 966c1c1..1c432a8 100644
--- a/ConstexprProperties.h
+++ b/ConstexprProperties.h
@@ -425,15 +425,45 @@ constexpr unsigned maxRotations() {
   );
 }
 
+template<typename UnsignedType, size_t size>
+constexpr auto hashIndexList(const ConstexprMagic::Array<unsigned, size>& indexList) {
+  constexpr unsigned maxDigitsStoreable = ConstexprMagic::Math::floor(
+    ConstexprMagic::Math::log10(
+      static_cast<double>(
+        std::numeric_limits<UnsignedType>::max()
+      )
+    )
+  );
+
+  static_assert(
+    size <= maxDigitsStoreable,
+    "The unsigned type with which hashIndexList was instantiated cannot hold as"
+    " many digits as the array to hash holds:"
+  );
+
+  UnsignedType hash = 0;
+  unsigned tenPowers = 1;
+
+  for(unsigned i = 0; i < size; ++i) {
+    if(indexList.at(i) > 9) {
+      throw "hashIndexList: Index list contains numbers greater than 9!";
+    }
+    hash += tenPowers * indexList.at(i);
+    tenPowers *= 10;
+  }
+
+  return hash;
+}
+
 // Some helper types
 template<typename SymmetryClass>
 using IndicesList = ArrayType<unsigned, SymmetryClass::size>;
 
-using IndexListStorageType = ConstexprMagic::DynamicUIntArray<unsigned>;
+using IndexListStorageType = unsigned;
 
 template<typename SymmetryClass>
 using RotationsSetType = ConstexprMagic::DynamicSet<
-  IndexListStorageType,
+  IndicesList<SymmetryClass>,
   maxRotations<SymmetryClass>()
 >;
 
@@ -454,7 +484,7 @@ template<typename SymmetryClass>
 constexpr auto generateAllRotations(const IndicesList<SymmetryClass>& indices) {
   RotationsSetType<SymmetryClass> rotations;
 
-  rotations.insert(IndexListStorageType {indices});
+  rotations.insert(indices);
 
   ChainStructuresArrayType<SymmetryClass> chainStructures;
   chainStructures.push_back(indices);
@@ -471,11 +501,8 @@ constexpr auto generateAllRotations(const IndicesList<SymmetryClass>& indices) {
       chain.back()
     );
 
-    auto storageType = IndexListStorageType {generated};
-
-    auto rotationsLB = rotations.getLowerBound(storageType);
-    if(!rotations.lowerBoundMeansContains(rotationsLB, storageType)) {
-      rotations.insertAt(rotationsLB, storageType);
+    if(!rotations.contains(generated)) {
+      rotations.insert(generated);
       chainStructures.push_back(generated);
       chain.push_back(0);
     } else {
@@ -577,7 +604,7 @@ constexpr auto symmetryTransitionMappings() {
 
   do {
     auto mapped = symPosMapping(indexMapping);
-    auto storageVersion = IndexListStorageType {mapped};
+    auto storageVersion = hashIndexList<IndexListStorageType>(mapped);
 
     if(!encounteredMappings.contains(storageVersion)) {
       auto angularDistortion = calculateAngularDistortion(
@@ -632,9 +659,10 @@ constexpr auto symmetryTransitionMappings() {
       auto allRotations = generateAllRotations<SymmetryClassTo>(mapped);
 
       for(const auto& rotation : allRotations) {
-        auto lowerBound = encounteredMappings.getLowerBound(rotation);
-        if(!encounteredMappings.lowerBoundMeansContains(lowerBound, rotation)) {
-          encounteredMappings.insertAt(lowerBound, rotation);
+        auto hashed = hashIndexList<IndexListStorageType>(rotation);
+
+        if(!encounteredMappings.contains(hashed)) {
+          encounteredMappings.insert(hashed);
         }
       }
     }
@@ -691,7 +719,7 @@ constexpr auto ligandLossMappings(const unsigned& deletedSymmetryPosition) {
   do {
     auto mapped = symPosMapping(indexMapping);
 
-    if(!encounteredMappings.contains(IndexListStorageType {mapped})) {
+    if(!encounteredMappings.contains(hashIndexList<IndexListStorageType>(mapped))) {
       auto angularDistortion = calculateAngleDistortion<
         SymmetryClassTo,
         SymmetryClassFrom
@@ -732,9 +760,10 @@ constexpr auto ligandLossMappings(const unsigned& deletedSymmetryPosition) {
       auto allRotations = generateAllRotations<SymmetryClassFrom>(mapped);
 
       for(const auto& rotation : allRotations) {
-        auto lowerBound = encounteredMappings.getLowerBound(rotation);
-        if(!encounteredMappings.lowerBoundMeansContains(lowerBound, rotation)) {
-          encounteredMappings.insertAt(lowerBound, rotation);
+        auto hashed = hashIndexList<IndexListStorageType>(rotation);
+
+        if(!encounteredMappings.contains(hashed)) {
+          encounteredMappings.insert(hashed);
         }
       }
     }
diff --git a/ISSUE.rst b/ISSUE.rst
index 7ce7578..04030f2 100644
--- a/ISSUE.rst
+++ b/ISSUE.rst
@@ -50,3 +50,12 @@ New observations:
   algorithmic improvements at low levels has marked impact on compile time too!
   Focussing on often-repeated code learned from run-time profiling allows me to
   compile in the results for symmetries of size 6 in 15 mins.
+
+Other possible optimizations
+- Add a Bloom filter to large sets for O(1) membership checking (requires a hash
+  function implementation)
+- Add a Bloom filter, contains O(log N) -> O(1)
+- Base DynamicSet not on a sorted list, but on a tree, insert O(N) -> O(log N)
+
+With a proper Set implementation:
+- Compiles all symmetry problems in 10 mins
diff --git a/Primitives.h b/Primitives.h
index 6c687f0..ea9d709 100644
--- a/Primitives.h
+++ b/Primitives.h
@@ -1061,23 +1061,6 @@ using allSymmetryDataTypes = std::tuple<
   SquareAntiPrismatic // 8
 >;
 
-using limitedSymmetryDataTypes = std::tuple<
-  Linear, // 2
-  Bent,
-  TrigonalPlanar, // 3
-  TrigonalPyramidal,
-  TShaped,
-  Tetrahedral, // 4
-  SquarePlanar,
-  Seesaw,
-  SquarePyramidal, // 5
-  TrigonalBiPyramidal,
-  PentagonalPlanar,
-  Octahedral, // 6
-  TrigonalPrismatic,
-  PentagonalPyramidal
->;
-
 } // namespace data
 
 } // namespace Symmetry
diff --git a/Properties.h b/Properties.h
index 3d514de..822c5f0 100644
--- a/Properties.h
+++ b/Properties.h
@@ -15,16 +15,7 @@ namespace Symmetry {
  * identical for all symmetry data types (when using the optional-extended
  * version to avoid instantiating symmetryTransitionMappings with non-adjacent
  * symmetries), we can generate an upper triangular matrix of function pointers!
- *
- * Is proven by the following static_assert (commented out for performance)
  */
-/*static_assert(
-  std::is_same<
-    decltype(calculateMapping<data::Linear, data::Bent>),
-    decltype(calculateMapping<data::Linear, data::TrigonalPlanar>)
-  >::value,
-  "pointer-to-function types are not identical"
-);*/
 
 template<typename SymmetrySource, typename SymmetryTarget>
 struct mappingCalculationFunctionPointerFunctor {
@@ -37,7 +28,7 @@ struct mappingCalculationFunctionPointerFunctor {
 constexpr auto allMappingFunctions
 = ConstexprMagic::makeUpperTriangularMatrix(
   ConstexprMagic::TupleType::mapAllPairs<
-    data::limitedSymmetryDataTypes,
+    data::allSymmetryDataTypes,
     mappingCalculationFunctionPointerFunctor
   >()
 );
@@ -63,7 +54,7 @@ constexpr double smallestAngle __attribute__ ((unused))
 #ifdef USE_CONSTEXPR_TRANSITION_MAPPINGS
 constexpr auto allMappings = ConstexprMagic::makeUpperTriangularMatrix(
   ConstexprMagic::TupleType::mapAllPairs<
-    data::limitedSymmetryDataTypes,
+    data::allSymmetryDataTypes,
     mappingCalculationFunctor
   >()
 );
