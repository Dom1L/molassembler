#ifndef INCLUDE_CYCLIC_POLYGONS_LIB_H
#define INCLUDE_CYCLIC_POLYGONS_LIB_H

#include "constexpr_magic/Math.h"
#include "template_magic/Numeric.h"

#include <boost/optional.hpp>

#include <vector>

/* TODO
 * - Generalize central angle sum circumradius determination method since the
 *   circumradius of any size of polygon is calculable with this method.
 * - Change tests to show, but not fail on svrtan polynomial function failure
 *   boost::optional returning boost::none is not an error
 */

namespace CyclicPolygons {

namespace detail {

/*!
 * Implementation of recursive variable-for-loop-number call function. See 
 * documentation of recursiveLoopSummation.
 */
template<class CallFunction>
double recursiveLoopSummationImpl(
  CallFunction&& callFunction,
  std::vector<unsigned> indices,
  const unsigned& nLoops,
  const unsigned& upperLimit
);

/*! 
 * Function that allows summation of the return value of a function over a 
 * dynamic number of for-loops. Each embedded for-loop runs over the integer 
 * interval:
 * - From the enclosing for loop index plus one
 * - To the specified upper limit minus the number of missing indices (inclusive)
 *
 * So, e.g. recursiveLoopSummation(printIndices, 2, 3) prints::
 *   0, 1
 *   0, 2
 *   0, 3
 *   1, 2
 *   1, 3
 *   2, 3
 *
 * Requires:
 * - callFunction must accept a std::vector<unsigned> that contains the for-loop
 *   indices generated by the for loops
 * - nLoops is the 
 */
template<class CallFunction>
double recursiveLoopSummation(
  CallFunction&& callFunction,
  const unsigned& nLoops,
  const unsigned upperLimit
);

} // namespace detail


namespace analysis {

/*!
 * Scans the viable rho range of svrtanPolynomial and writes plot values and
 * search process meta information to the specified base name files. In the base
 * name, do not specify a file-extension.
 */
void writeSvrtanAnalysisFiles(
  const std::vector<double>& edgeLengths,
  const std::string& baseName
);

/*!
 * Scans the viable circumradius range of centralAnglesDeviation and writes
 * plot values and meta information to the specified base name files. In the
 * base name, do not specify a file-extension.
 */
void writeAngleAnalysisFiles(
  const std::vector<double>& edgeLengths,
  const std::string& baseName
);

} // namespace analysis


namespace math {

/*! 
 * Conversion constant from regular cyclic pentagon circumradius to
 * svrtanPolynomial rho
 */
static constexpr double radiusRhoConversionConstant = (
  10 - 2 * ConstexprMagic::Math::sqrt(5.0)
) / 4.0;

/*!
 * Calculates the elementary symmetric polynomial of k-th order for the passed
 * values.
 */
double elementarySymmetricPolynomial(
  const unsigned& k,
  const std::vector<double>& values
);

/* Generates a vector containing the unsigned integer sequence 
 * [start, start+ 1, ..., end] (end inclusive). If start and end are the same,
 * the sequence [start] is returned.
 *
 * This could be replaced with a struct that offers iterators that merely
 * generate the sequence, but do not store it. The implementation is okay for
 * short sequences, but potentially incredibly wasteful for large ones. 
 */
std::vector<unsigned> intSeq(
  const unsigned& start,
  const unsigned& end
);

//! Inline help function for more readable squares without invoking std::pow
template<typename T>
inline T square(const T& value) {
  return value * value;
}

/*! 
 * Calculates the angle in radians between adjacent side lengths in a triangle.
 */
double inverseLawOfCosines(
  const double& opposingSideLength,
  const double& adjacentSideLengthA,
  const double& adjacentSideLengthB
);

} // namespace math


namespace Pentagon {

//! Svrtan polynomial auxiliary equation lambda coefficient calculation function
double lambda(
  const unsigned& k,
  const double& rho, 
  const std::vector<double>& epsilon
);

//! Svrtan polynomial pentagon A5 coefficient calculation function
inline double A5(const std::vector<double>& lambdas) {
  return TemplateMagic::kahanSum(
    std::vector<double>{
      std::pow(lambdas[4], 4),
      (
        - 3 * lambdas[3]
        + 2 * lambdas[2]
        + lambdas[1]
        - 3
      ) * math::square(lambdas[4]),
      (
        - 2 * lambdas[3]
        - 4 * lambdas[1]
        + 2
      ) * lambdas[4],
      2 * math::square(lambdas[3]),
      (
        - 2 * lambdas[2]
        - 2 * lambdas[1]
        + 4 
      ) * lambdas[3],
      math::square(lambdas[2]),
      2 * lambdas[2],
      - 2 * lambdas[1],
      (
        lambdas[3] + 3
      ) * lambdas[0],
      2
    }
  );
}

//! Svrtan polynomial pentagon B5 coefficient calculation function
inline double B5(const std::vector<double>& lambdas) {
   return TemplateMagic::kahanSum(
    std::vector<double>{
      - std::pow(lambdas[4], 3),
      2 * math::square(lambdas[4]),
      (
         2 * lambdas[3] - lambdas[2]
      ) * lambdas[4],
      - 2 * lambdas[3],
      2 * lambdas[1],
      - lambdas[0],
      - 2
    }
  );
}

//! Svrtan polynomial pentagon Delta5 coefficient calculation function
inline double Delta5(const std::vector<double>& lambdas) {
  return (
    lambdas[0]
    + 2 * TemplateMagic::kahanSum(
      std::vector<double>{
        lambdas[1],
        lambdas[2],
        lambdas[3],
        lambdas[4],
        1
      }
    )
  );
}

/*!
 * Calculates the Svrtan polynomial for a specified rho and a set of epsilons
 * (as specified in the paper). Since the epsilons are merely the elementary
 * symmetric polynomials of the squared edge lengths and not a function of rho,
 * to pre-empt re-calculation for multiple rho evaluations, the set of epsilons
 * must be passed.
 *
 * Paper:
 * Svrtan, Dragutin. "On Circumradius Equations of Cyclic Polygons", 2009
 */
double svrtanPolynomial(
  const double& rho,
  const std::vector<double>& epsilon
);

/*!
 * Calculates the central angles of a cyclic pentagon, in the same sequence as
 * the passed edge lengths
 */
std::vector<double> centralAngles(
  const double& circumradius,
  const std::vector<double>& edgeLengths
);

/*!
 * Calculates the deviation of the sum of all central angles of a cyclic pentagon
 * from 2π. If the deviation is zero, then the pentagon is closed.
 */
double centralAnglesDeviation(
  const double& circumradius,
  const std::vector<double>& edgeLengths
);

//! The first derivative of centralAnglesDeviation
double centralAnglesDeviationDerivative(
  const double& circumradius,
  const std::vector<double>& edgeLengths
);

//! The second derivative of centralAnglesDeviation
double centralAnglesDeviationSecondDerivative(
  const double& circumradius,
  const std::vector<double>& edgeLengths
);

/*! 
 * Returns the circumradius of a regular pentagon as a function of the edge
 * length.
 */
constexpr double regularCircumradius(const double& a) {
  return 2 * a / (
    ConstexprMagic::Math::sqrt(10 - 2 * ConstexprMagic::Math::sqrt(5))
  );
}

/*! 
 * Determines the circumradius of the unique convex cyclic pentagon defined by 
 * the passed edge lengths using a root search on the centralAnglesDeviation
 * function. Very reliable, but can throw.
 */
double convexCircumradius(const std::vector<double>& edgeLengths);

/*!
 * Determines the circumradius of the unique convex cyclic pentagon defined by
 * the passed edge lengths using a root search on the Svrtan polynomial. Always
 * works for miniscule edge length standard deviations relative to the mean, 
 * only 95% reliable for larger than miniscule relative standard deviations. 
 * Does not throw, but returns only an optional.
 */
boost::optional<double> convexCircumradiusSvrtan(const std::vector<double>& edgeLengths);

/* In a cyclic pentagon, if the circumradius is known, then isosceles triangles
 * can be spanned from every edge to the center of the circle and the base
 * angles calculated via inverting the law of cosines. The angle between two
 * edges of the pentagon is then merely the sum of the neighboring internal
 * triangle angles.
 */
std::vector<double> internalAngles(
  const std::vector<double>& edgeLengths,
  const double& circumradius
);

/*! 
 * Returns whether a guess for a root is valid or not by calculating all
 * internal angles and checking whether the sum is very close to 3π.
 */
bool validateRhoGuess(
  const std::vector<double>& edgeLengths,
  const double& rhoGuess
);

} // namespace Pentagon


namespace Quadrilateral {

//! Calculates the circumradius of the unique convex cyclic quadrilateral.
double convexCircumradius(const std::vector<double> edgeLengths);

/* For a cyclic quadrilateral, the internal angle between adjacent edges a and b
 * is given as
 *
 *               a² + b² - c² - d²
 *    cos(phi) = -----------------
 *                 2 (ab + cd)
 *
 * This general structure from adjacent and non-adjacent edge lengths is
 * calculated below.
 */
double calculateInternalAngle(
  const std::pair<double, double>& adjacentEdgeLengths,
  const std::pair<double, double>& nonAdjacentEdgeLengths
);

/*! 
 * Returns the sequence of internal angles where the first returned angle is
 * between the first and second edges.
 */
std::vector<double> internalAngles(const std::vector<double>& edgeLengths);

} // namespace Quadrilateral


namespace Triangle {

/*! 
 * Returns the sequence of internal angles where the first returned angle is
 * between the first and second edges.
 */
std::vector<double> internalAngles(const std::vector<double>& edgeLengths);

} // namespace Triangle

/*! 
 * Returns whether a cyclic polygon exists for the specified sequence of edge
 * lengths.
 */
bool exists(const std::vector<double>& edgeLengths);

/*! 
 * Returns internal angles of the convex cyclic polygon specified by the passed
 * edge lengths. Angles are returned in the following sequence:
 *
 *   edge lengths: a1, a2, ..., aN
 *   angles: a1 ∡ a2, a2 ∡ a3, ..., a(N-1) ∡ aN, aN ∡ a1
 *
 * Requires that the passed vector of edge lengths contains 3-5 edges.
 * The cyclic polygon must exist (use cyclicPolygoonExists to check beforehand)
 * and no edge length may be zero (assumes logical error in calling code).
 */
std::vector<double> internalAngles(const std::vector<double>& edgeLengths);

} // namespace CyclicPolygons


#endif
